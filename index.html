<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Booha Tetris – Practice Deck</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Noto+Sans+JP:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bgDark:#050816;
      --bgGlow:#0b1530;
      --gold:#ffd166;
      --pink:#ff7eb9;
      --aqua:#7dd3fc;
      --outline:rgba(255,255,255,0.35);
    }

    *{
      box-sizing:border-box;
      margin:0;
      padding:0;
    }

    html, body{
      height:100%;
      width:100%;
      overflow:hidden;
    }

    body{
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(circle at top, #1f2937 0%, #020617 55%, #000000 100%);
      font-family:'Noto Sans JP', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color:#f9fafb;
    }

    .shell{
      position:relative;
      padding:18px 22px 24px;
      border-radius:24px;
      background:radial-gradient(circle at top, rgba(148,163,255,0.25), rgba(15,23,42,0.98));
      box-shadow:
        0 0 40px rgba(56,189,248,0.45),
        0 0 80px rgba(248,250,252,0.08);
      border:1px solid rgba(148,163,255,0.5);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
    }

    .shell::before{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius:26px;
      background:
        radial-gradient(circle at 0% 0%, rgba(236,72,153,0.27), transparent 60%),
        radial-gradient(circle at 100% 100%, rgba(56,189,248,0.24), transparent 60%);
      z-index:-1;
      filter:blur(10px);
      opacity:0.85;
      animation:orbGlow 6s ease-in-out infinite alternate;
    }

    @keyframes orbGlow{
      0%{transform:translate3d(-4px,-4px,0) scale(1);}
      100%{transform:translate3d(4px,4px,0) scale(1.02);}
    }

    h1{
      font-family:'Cinzel',serif;
      font-weight:900;
      letter-spacing:0.12em;
      font-size:1.05rem;
      text-transform:uppercase;
      text-align:center;
      color:#e5e7eb;
      text-shadow:
        0 0 8px rgba(248,250,252,0.9),
        0 0 16px rgba(251,113,133,0.8);
    }

    h1 span{
      display:block;
      font-size:0.8rem;
      letter-spacing:0.28em;
      color:#a5b4fc;
      text-shadow:none;
      margin-top:2px;
    }

    .hud{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:0.8rem;
      color:#e5e7eb;
      padding:4px 2px 0;
      column-gap:8px;
    }

    .hud span.label{
      opacity:0.75;
    }

    .hud span.value{
      font-weight:700;
      color:var(--gold);
      text-shadow:0 0 6px rgba(250,204,21,0.9);
    }

    .hud span.next{
      color:var(--pink);
      text-shadow:0 0 6px rgba(248,113,113,0.9);
    }

    canvas{
      margin-top:8px;
      border-radius:18px;
      border:1px solid var(--outline);
      background:radial-gradient(circle at top, #020617 0%, #000 50%, #020617 100%);
      box-shadow:
        0 0 22px rgba(59,130,246,0.55),
        0 0 50px rgba(15,23,42,0.9);
      image-rendering:pixelated;
    }

    /* floating sparkles overlay */
    .sparkle-overlay{
      pointer-events:none;
      position:absolute;
      inset:0;
      overflow:hidden;
      border-radius:24px;
      mix-blend-mode:screen;
      opacity:0.45;
    }

    .spark{
      position:absolute;
      width:3px;
      height:3px;
      border-radius:50%;
      background:radial-gradient(circle, #e5e7eb 0%, rgba(244,244,245,0) 70%);
      box-shadow:0 0 8px rgba(255,255,255,0.9);
      animation:floatUp 8s linear infinite;
    }

    .spark:nth-child(2){animation-duration:10s;}
    .spark:nth-child(3){animation-duration:12s;}
    .spark:nth-child(4){animation-duration:9s;}
    .spark:nth-child(5){animation-duration:11s;}
    .spark:nth-child(6){animation-duration:13s;}

    @keyframes floatUp{
      0%{transform:translate3d(0,120%,0) scale(0.6); opacity:0;}
      18%{opacity:1;}
      80%{opacity:1;}
      100%{transform:translate3d(0,-40%,0) scale(1.05); opacity:0;}
    }

    /* Question overlay */
    #questionOverlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,20,0.82);
      backdrop-filter:blur(8px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
    }

    .q-card{
      width:min(92vw,420px);
      border-radius:20px;
      padding:20px 18px 18px;
      background:radial-gradient(circle at top,#111827,#020617 65%,#020617 100%);
      border:1px solid rgba(248,250,252,0.25);
      box-shadow:
        0 0 30px rgba(251,113,133,0.8),
        0 0 80px rgba(56,189,248,0.6);
      color:#f9fafb;
    }

    .q-title{
      font-family:'Cinzel',serif;
      font-size:1.05rem;
      text-align:center;
      text-transform:uppercase;
      letter-spacing:0.16em;
      margin-bottom:8px;
      color:#fefce8;
      text-shadow:
        0 0 6px rgba(250,204,21,0.9),
        0 0 14px rgba(250,250,250,0.8);
    }

    .q-sub{
      text-align:center;
      font-size:0.8rem;
      color:#a5b4fc;
      margin-bottom:10px;
    }

    #questionText{
      font-size:0.9rem;
      line-height:1.5;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(15,23,42,0.9);
      border:1px solid rgba(148,163,255,0.5);
      margin-bottom:14px;
    }

    .q-footer{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:0.75rem;
      color:#9ca3af;
      margin-bottom:8px;
    }

    #continueBtn{
      display:block;
      width:100%;
      border:none;
      border-radius:999px;
      padding:9px 14px;
      font-size:0.9rem;
      font-weight:700;
      letter-spacing:0.08em;
      text-transform:uppercase;
      background:linear-gradient(120deg,#f97316,#fb7185,#e879f9);
      color:#0b1020;
      cursor:pointer;
      box-shadow:
        0 0 16px rgba(248,113,113,0.9),
        0 0 32px rgba(236,72,153,0.7);
      transition:transform 0.12s ease, box-shadow 0.12s ease, filter 0.12s ease;
    }

    #continueBtn:active{
      transform:scale(0.97) translateY(1px);
      box-shadow:
        0 0 10px rgba(248,113,113,0.65),
        0 0 20px rgba(236,72,153,0.5);
      filter:brightness(0.94);
    }

    @media (max-width:600px){
      .shell{
        transform:scale(0.9);
      }
    }
  </style>
</head>
<body>
<div class="shell">
  <h1>
    Booha Tetris
    <span>LINES → QUESTIONS</span>
  </h1>

  <div class="hud">
    <div>
      <span class="label">Lines:</span>
      <span class="value" id="linesCount">0</span>
    </div>
    <div style="text-align:right;">
      <span class="label">Next Question at</span>
      <span class="next" id="nextAt">10</span>
      <span class="label">lines</span>
    </div>
  </div>

  <canvas id="game" width="320" height="640"></canvas>

  <div class="sparkle-overlay">
    <div class="spark" style="left:10%;"></div>
    <div class="spark" style="left:30%;"></div>
    <div class="spark" style="left:50%;"></div>
    <div class="spark" style="left:70%;"></div>
    <div class="spark" style="left:85%;"></div>
    <div class="spark" style="left:42%;"></div>
  </div>
</div>

<!-- Question overlay (every 10 lines) -->
<div id="questionOverlay">
  <div class="q-card">
    <div class="q-title">Checkpoint</div>
    <div class="q-sub">Booha Question Gate</div>
    <div id="questionText">
      <!-- placeholder question text injected by JS -->
    </div>
    <div class="q-footer">
      <span id="qProgress">Question 1 / 60</span>
      <span>Press continue to answer in class.</span>
    </div>
    <button id="continueBtn">Continue</button>
  </div>
</div>

<script>
// ===== Utility =====
function getRandomInt(min, max){
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// ===== Tetromino sequence =====
const tetrominoSequence = [];

function generateSequence(){
  const sequence = ['I','J','L','O','S','T','Z'];
  while(sequence.length){
    const rand = getRandomInt(0, sequence.length - 1);
    const name = sequence.splice(rand, 1)[0];
    tetrominoSequence.push(name);
  }
}

function getNextTetromino(){
  if (tetrominoSequence.length === 0){
    generateSequence();
  }
  const name = tetrominoSequence.pop();
  const matrix = tetrominos[name];
  const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);
  const row = name === 'I' ? -1 : -2;
  return { name, matrix, row, col };
}

// Rotate NxN matrix
function rotate(matrix){
  const N = matrix.length - 1;
  const result = matrix.map((row, i) =>
    row.map((val, j) => matrix[N - j][i])
  );
  return result;
}

// Check validity
function isValidMove(matrix, cellRow, cellCol){
  for (let row = 0; row < matrix.length; row++){
    for (let col = 0; col < matrix[row].length; col++){
      if (matrix[row][col] && (
          cellCol + col < 0 ||
          cellCol + col >= playfield[0].length ||
          cellRow + row >= playfield.length ||
          playfield[cellRow + row][cellCol + col]
        )){
        return false;
      }
    }
  }
  return true;
}

// ===== Game setup =====
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');
const grid = 32;

// playfield: 10 x 20 + 2 hidden rows
const playfield = [];
for (let row = -2; row < 20; row++){
  playfield[row] = [];
  for (let col = 0; col < 10; col++){
    playfield[row][col] = 0;
  }
}

// Tetrominos
const tetrominos = {
  'I': [
    [0,0,0,0],
    [1,1,1,1],
    [0,0,0,0],
    [0,0,0,0]
  ],
  'J': [
    [1,0,0],
    [1,1,1],
    [0,0,0],
  ],
  'L': [
    [0,0,1],
    [1,1,1],
    [0,0,0],
  ],
  'O': [
    [1,1],
    [1,1],
  ],
  'S': [
    [0,1,1],
    [1,1,0],
    [0,0,0],
  ],
  'Z': [
    [1,1,0],
    [0,1,1],
    [0,0,0],
  ],
  'T': [
    [0,1,0],
    [1,1,1],
    [0,0,0],
  ]
};

// Booha colors for each tetromino
const colors = {
  'I':'#7dd3fc',   // aqua
  'O':'#facc15',   // gold
  'T':'#e879f9',   // pink-purple
  'S':'#4ade80',   // green
  'Z':'#fb7185',   // rose
  'J':'#a855f7',   // violet
  'L':'#f97316'    // orange
};

// ===== Sparkle particles for cleared lines =====
const particles = [];

function createSparklesForRow(rowIndex){
  const baseY = rowIndex * grid + grid / 2;
  for (let col = 0; col < 10; col++){
    const baseX = col * grid + grid / 2;
    for (let i = 0; i < 6; i++){
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 2 + 0.5;
      particles.push({
        x: baseX,
        y: baseY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 0.5,
        life: 30 + Math.random() * 20,
        alpha: 1
      });
    }
  }
}

function updateAndDrawParticles(){
  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.04;       // tiny gravity
    p.life -= 1;
    p.alpha -= 0.03;

    if (p.life <= 0 || p.alpha <= 0){
      particles.splice(i,1);
      continue;
    }

    context.save();
    context.globalAlpha = p.alpha;
    context.fillStyle = '#ffeaa7';
    context.fillRect(p.x - 2, p.y - 2, 4, 4);
    context.restore();
  }
}

// ===== Question system (every 10 lines) =====
const questions = Array.from({length:60}, (_, i) =>
  `Question ${i+1} placeholder – add your Booha English/Japanese prompt here.`
);

let linesClearedTotal = 0;
let currentQuestionIndex = 0;
let rAF = null;
let gameOver = false;
let isPausedForQuestion = false;

const linesCountEl = document.getElementById('linesCount');
const nextAtEl = document.getElementById('nextAt');
const questionOverlay = document.getElementById('questionOverlay');
const questionTextEl = document.getElementById('questionText');
const qProgressEl = document.getElementById('qProgress');
const continueBtn = document.getElementById('continueBtn');

function getNextThreshold(){
  if (currentQuestionIndex >= questions.length) return null;
  return (currentQuestionIndex + 1) * 10;
}

function updateHud(){
  linesCountEl.textContent = linesClearedTotal;
  const next = getNextThreshold();
  if (next === null){
    nextAtEl.textContent = '—';
  } else {
    nextAtEl.textContent = next;
  }
}

function maybeTriggerQuestion(){
  const next = getNextThreshold();
  if (next === null) return;
  if (linesClearedTotal >= next){
    showQuestion();
  }
}

function showQuestion(){
  isPausedForQuestion = true;
  const q = questions[currentQuestionIndex] || 'Checkpoint question placeholder.';
  questionTextEl.textContent = q;
  qProgressEl.textContent = `Question ${currentQuestionIndex+1} / ${questions.length}`;
  questionOverlay.style.display = 'flex';
}

continueBtn.addEventListener('click', () => {
  currentQuestionIndex = Math.min(currentQuestionIndex + 1, questions.length);
  questionOverlay.style.display = 'none';
  isPausedForQuestion = false;
  updateHud();
});

// ===== Place tetromino and check for cleared lines =====
let tetromino = getNextTetromino();
let count = 0;

// place the tetromino on the playfield
function placeTetromino(){
  for (let row = 0; row < tetromino.matrix.length; row++){
    for (let col = 0; col < tetromino.matrix[row].length; col++){
      if (tetromino.matrix[row][col]){
        if (tetromino.row + row < 0){
          return showGameOver();
        }
        playfield[tetromino.row + row][tetromino.col + col] = tetromino.name;
      }
    }
  }

  let linesClearedThisDrop = 0;

  // from bottom-up
  for (let row = playfield.length - 1; row >= 0; ){
    if (playfield[row].every(cell => !!cell)){
      // sparkles along this row
      createSparklesForRow(row);
      linesClearedThisDrop++;

      // drop every row above
      for (let r = row; r >= 0; r--){
        for (let c = 0; c < playfield[r].length; c++){
          playfield[r][c] = playfield[r-1]?.[c] || 0;
        }
      }
      // stay on same row index (since we pulled everything down)
    } else {
      row--;
    }
  }

  if (linesClearedThisDrop > 0){
    linesClearedTotal += linesClearedThisDrop;
    updateHud();
    maybeTriggerQuestion();
  }

  tetromino = getNextTetromino();
}

// Game over
function showGameOver(){
  cancelAnimationFrame(rAF);
  gameOver = true;

  context.save();
  context.fillStyle = 'rgba(0,0,0,0.75)';
  context.fillRect(0, canvas.height / 2 - 40, canvas.width, 80);

  context.fillStyle = '#f9fafb';
  context.font = '28px Cinzel, serif';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.shadowColor = '#f87171';
  context.shadowBlur = 14;
  context.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 4);

  context.font = '14px "Noto Sans JP", sans-serif';
  context.shadowBlur = 0;
  context.fillStyle = '#e5e7eb';
  context.fillText('Press F5 to try again', canvas.width / 2, canvas.height / 2 + 20);
  context.restore();
}

// ===== Game loop =====
function loop(){
  rAF = requestAnimationFrame(loop);
  context.clearRect(0,0,canvas.width,canvas.height);

  // draw playfield
  for (let row = 0; row < 20; row++){
    for (let col = 0; col < 10; col++){
      if (playfield[row][col]){
        const name = playfield[row][col];
        context.fillStyle = colors[name] || '#e5e7eb';
        context.fillRect(col * grid, row * grid, grid-1, grid-1);
      } else {
        // faint grid background
        context.fillStyle = 'rgba(15,23,42,0.45)';
        context.fillRect(col * grid, row * grid, grid-1, grid-1);
      }
    }
  }

  // draw & update particles on top
  updateAndDrawParticles();

  if (tetromino){
    if (!gameOver && !isPausedForQuestion){
      // fall every 35 frames
      if (++count > 35){
        tetromino.row++;
        count = 0;
        if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)){
          tetromino.row--;
          placeTetromino();
        }
      }
    }

    context.fillStyle = colors[tetromino.name];

    for (let row = 0; row < tetromino.matrix.length; row++){
      for (let col = 0; col < tetromino.matrix[row].length; col++){
        if (tetromino.matrix[row][col]){
          const x = (tetromino.col + col) * grid;
          const y = (tetromino.row + row) * grid;
          context.fillRect(x, y, grid-1, grid-1);
        }
      }
    }
  }
}

// ===== Controls =====
document.addEventListener('keydown', function(e){
  if (gameOver || isPausedForQuestion) return;
  if (!tetromino) return;

  // left / right
  if (e.which === 37 || e.which === 39){
    const col = e.which === 37 ? tetromino.col - 1 : tetromino.col + 1;
    if (isValidMove(tetromino.matrix, tetromino.row, col)){
      tetromino.col = col;
    }
  }

  // rotate (up)
  if (e.which === 38){
    const matrix = rotate(tetromino.matrix);
    if (isValidMove(matrix, tetromino.row, tetromino.col)){
      tetromino.matrix = matrix;
    }
  }

  // soft drop (down)
  if (e.which === 40){
    const row = tetromino.row + 1;
    if (!isValidMove(tetromino.matrix, row, tetromino.col)){
      tetromino.row = row - 1;
      placeTetromino();
      return;
    }
    tetromino.row = row;
  }
});

// ===== Start =====
updateHud();
rAF = requestAnimationFrame(loop);
</script>
</body>
</html>
